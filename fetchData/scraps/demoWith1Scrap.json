{
  "id": "crwirlnie-ev",
  "createdAt": "2022-04-09T13:41:05.608Z",
  "updatedAt": "2022-04-18T16:37:28.928Z",
  "publishedAt": "2022-04-09T13:41:05.608Z",
  "revisedAt": "2022-04-18T16:37:28.928Z",
  "date": "2022-04-08T15:00:00.000Z",
  "highlight": "<p>ここにまとめを書きます！</p>",
  "scraps": [
    {
      "id": "0n-aq2klw",
      "createdAt": "2022-04-09T13:24:48.078Z",
      "updatedAt": "2022-04-18T16:11:59.530Z",
      "publishedAt": "2022-04-09T13:24:48.078Z",
      "revisedAt": "2022-04-18T16:11:59.530Z",
      "tags": [
        {
          "id": "smq5fskl9",
          "createdAt": "2022-04-10T03:58:13.724Z",
          "updatedAt": "2022-04-10T03:58:13.724Z",
          "publishedAt": "2022-04-10T03:58:13.724Z",
          "revisedAt": "2022-04-10T03:58:13.724Z",
          "title": "React",
          "description": "<p>React関連の記事</p>"
        }
      ],
      "links": [
        {
          "fieldId": "link",
          "url": "https://reactjs.org/blog/2022/03/29/react-v18.html"
        }
      ],
      "title": "React18リリース",
      "body": [
        {
          "fieldId": "plainText",
          "content": "## 新機能 - 自動バッチ処理の更新\n自動バッチ処理は、複数のstateの更新を、1回の再レンダリングでグルーピングする機能です。\n\nReact18以前はsetTimeoutやイベントハンドラでのstate更新は、stateを更新するたびに再レンダリングが起きていた。\n```javascript\n// 以前はsetCountとsetFlagで2回レンダリングしていた\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n}, 1000);\n\n// React18ではsetCountとsetFlagの更新を、1回のレンダリングでまとめるようになった\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n}, 1000);\n```\n\n## 新機能 - Transitions\nすぐに反映する必要があるものと、そうでないものを区別できるようになった。\nキー入力やクリックでstateが更新されるときに、すぐに反映する必要がないものはstartTransitionで囲んで使うことで、中断できるようになった。\n\n```javascript\nimport {startTransition} from 'react';\n\n// 入力された値を表示 (すぐに反映される)\nsetInputValue(input);\n\n// 入力した値で検索 (すぐに反映されない)\nstartTransition(() => {\n  setSearchQuery(input);\n});\n```\n\n## 新機能 - Suspenseのサーバーレンダリング対応\nSuspenseはデータの取得中状態を宣言的に記述するためのコンポーネントです。\nSuspenseはpromiseをthrowされたときに、fallbackで指定した要素を返し、データが取得できると、Suspenseで囲んだ要素を返すことができる。\n生のReactではpromiseをthrowさせるには追加のコードが必要で、RelayやSWRなどのライブラリを併用することが推奨されている。\n\n```javascript\n<Suspense fallback={<Spinner />}>\n  <Comments />\n</Suspense>\n```\n\nStrictモードの挙動変更\n開発時はコンポーネントがマウントされるたびに、全てのコンポーネントを自動的にアンマウント、再マウントし、2回目のマウントで表示するようになった。\n将来的に、ステートを維持した状態でUIのセクションを追加・削除する機能を追加する予定で、複数回のマウント・アンマウントに強いコンポーネントが必要なためだそうです。\n"
        }
      ],
      "related": [
        {
          "id": "2dpfu2ymk",
          "createdAt": "2022-04-09T13:26:22.478Z",
          "updatedAt": "2022-04-18T16:10:30.716Z",
          "publishedAt": "2022-04-09T13:26:22.478Z",
          "revisedAt": "2022-04-18T16:10:30.716Z",
          "tags": [
            {
              "id": "smq5fskl9"
            }
          ],
          "links": [],
          "title": "React 型定義更新",
          "body": [
            {
              "fieldId": "plainText",
              "content": "Functional Componentで暗黙的なchildrenが削除された。\n\n```typescript\nimport * as React from 'react';\n\nconst Input: React.FC = ({ children }) => <div>{children}</div>;\n//                         ^^^^^^^^ will error with \"Property 'children'\n//                                  does not exist on type '{}'.\n<Input>children</Input>;\n```\n\n以下のように明示的に書く必要がある。\n\n```typescript\nimport * as React from 'react';\n\ninterface InputProps {\n\ttype: string;\n}\n\nconst Input: React.FC<InputProps> = ({ type }) => <input type={type} />;\n\n<Input type=\"search\" />;\n```"
            }
          ],
          "related": [
            {
              "id": "0n-aq2klw"
            }
          ]
        }
      ]
    },
    {
      "id": "2dpfu2ymk",
      "createdAt": "2022-04-09T13:26:22.478Z",
      "updatedAt": "2022-04-18T16:10:30.716Z",
      "publishedAt": "2022-04-09T13:26:22.478Z",
      "revisedAt": "2022-04-18T16:10:30.716Z",
      "tags": [
        {
          "id": "smq5fskl9",
          "createdAt": "2022-04-10T03:58:13.724Z",
          "updatedAt": "2022-04-10T03:58:13.724Z",
          "publishedAt": "2022-04-10T03:58:13.724Z",
          "revisedAt": "2022-04-10T03:58:13.724Z",
          "title": "React",
          "description": "<p>React関連の記事</p>"
        }
      ],
      "links": [],
      "title": "React 型定義更新",
      "body": [
        {
          "fieldId": "plainText",
          "content": "Functional Componentで暗黙的なchildrenが削除された。\n\n```typescript\nimport * as React from 'react';\n\nconst Input: React.FC = ({ children }) => <div>{children}</div>;\n//                         ^^^^^^^^ will error with \"Property 'children'\n//                                  does not exist on type '{}'.\n<Input>children</Input>;\n```\n\n以下のように明示的に書く必要がある。\n\n```typescript\nimport * as React from 'react';\n\ninterface InputProps {\n\ttype: string;\n}\n\nconst Input: React.FC<InputProps> = ({ type }) => <input type={type} />;\n\n<Input type=\"search\" />;\n```"
        }
      ],
      "related": [
        {
          "id": "0n-aq2klw",
          "createdAt": "2022-04-09T13:24:48.078Z",
          "updatedAt": "2022-04-18T16:11:59.530Z",
          "publishedAt": "2022-04-09T13:24:48.078Z",
          "revisedAt": "2022-04-18T16:11:59.530Z",
          "tags": [
            {
              "id": "smq5fskl9"
            }
          ],
          "links": [
            {
              "fieldId": "link",
              "url": "https://reactjs.org/blog/2022/03/29/react-v18.html"
            }
          ],
          "title": "React18リリース",
          "body": [
            {
              "fieldId": "plainText",
              "content": "## 新機能 - 自動バッチ処理の更新\n自動バッチ処理は、複数のstateの更新を、1回の再レンダリングでグルーピングする機能です。\n\nReact18以前はsetTimeoutやイベントハンドラでのstate更新は、stateを更新するたびに再レンダリングが起きていた。\n```javascript\n// 以前はsetCountとsetFlagで2回レンダリングしていた\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n}, 1000);\n\n// React18ではsetCountとsetFlagの更新を、1回のレンダリングでまとめるようになった\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n}, 1000);\n```\n\n## 新機能 - Transitions\nすぐに反映する必要があるものと、そうでないものを区別できるようになった。\nキー入力やクリックでstateが更新されるときに、すぐに反映する必要がないものはstartTransitionで囲んで使うことで、中断できるようになった。\n\n```javascript\nimport {startTransition} from 'react';\n\n// 入力された値を表示 (すぐに反映される)\nsetInputValue(input);\n\n// 入力した値で検索 (すぐに反映されない)\nstartTransition(() => {\n  setSearchQuery(input);\n});\n```\n\n## 新機能 - Suspenseのサーバーレンダリング対応\nSuspenseはデータの取得中状態を宣言的に記述するためのコンポーネントです。\nSuspenseはpromiseをthrowされたときに、fallbackで指定した要素を返し、データが取得できると、Suspenseで囲んだ要素を返すことができる。\n生のReactではpromiseをthrowさせるには追加のコードが必要で、RelayやSWRなどのライブラリを併用することが推奨されている。\n\n```javascript\n<Suspense fallback={<Spinner />}>\n  <Comments />\n</Suspense>\n```\n\nStrictモードの挙動変更\n開発時はコンポーネントがマウントされるたびに、全てのコンポーネントを自動的にアンマウント、再マウントし、2回目のマウントで表示するようになった。\n将来的に、ステートを維持した状態でUIのセクションを追加・削除する機能を追加する予定で、複数回のマウント・アンマウントに強いコンポーネントが必要なためだそうです。\n"
            }
          ],
          "related": [
            {
              "id": "2dpfu2ymk"
            }
          ]
        }
      ]
    },
    {
      "id": "rpkgdvmgc6x",
      "createdAt": "2022-04-09T13:35:27.602Z",
      "updatedAt": "2022-04-18T16:18:11.248Z",
      "publishedAt": "2022-04-09T13:35:27.602Z",
      "revisedAt": "2022-04-18T16:18:11.248Z",
      "tags": [],
      "links": [],
      "title": "Rome Formatterリリース",
      "body": [
        {
          "fieldId": "plainText",
          "content": "RomeはBabel, ESLint, Webpack, Prettier, Jestの代替を目指しているオールインワンツールで、TypeScript, HTML, CSSなどのフォーマッターかつ、リンターかつ、バンドラーの役割を目指しているツールです。\n\nRustでの再実装を進めており、今回フォーマッターとしての機能が使えるようになりました。\nVSCodeのプラグインも配布されています。\n<img src=\"https://images.microcms-assets.io/assets/1eee0d842b03431580c3bb6f540e9e7b/2e384dc5ad0f424089b89baac3fd6fb0/rome_vscode.png\" alt=\"vscode-rome\" width=\"812\" height=\"664\" />\n\n## Rome Formatterとprettierの挙動の違い\nRome Formatterでは、エラーリカバリーを強化しています。\n\n例えば、4行目に構文エラーがあっても、6行目のフォーマットが効きます。\nPrettierの場合は4行目の構文エラーが原因で、6行目のフォーマットが効きません。\n\nフォーマットを当てる前\n<img src=\"https://images.microcms-assets.io/assets/1eee0d842b03431580c3bb6f540e9e7b/ca522be9f9de46549522c6ca8ff8e233/rome_formatter_before.png\" alt=\"before-rome-format\" width=\"963\" height=\"348\" />\n\nフォーマットを当てた後\n<img src=\"https://images.microcms-assets.io/assets/1eee0d842b03431580c3bb6f540e9e7b/06c26a801708445daca56074de8d47c3/rome_formatter_after.png\" alt=\"after-rome-format\" width=\"592\" height=\"362\" />\n\n## Rome Formatterとprettierの処理速度の違い\n規模の大きなOSSに対してフォーマットをかけた時の速度を測定しているそうです。\n\n規模の大きなOSSとして、ESLint, Webpack, TypeScriptを選らんで実施したそうです。\nRome FormatterはPrettierと比較して、9-12倍高速だそうです。\n\n<img src=\"https://images.microcms-assets.io/assets/1eee0d842b03431580c3bb6f540e9e7b/5570e8a47fc242e48885d93988b40c44/rome_formatter_vs_prettier.png\" alt=\"format-speed\" width=\"1020\" height=\"1020\" />\n"
        }
      ],
      "related": []
    },
    {
      "id": "dsebo5n88fo",
      "createdAt": "2022-04-09T13:28:24.877Z",
      "updatedAt": "2022-04-18T16:38:07.964Z",
      "publishedAt": "2022-04-09T13:28:24.877Z",
      "revisedAt": "2022-04-18T16:38:07.964Z",
      "tags": [],
      "links": [
        {
          "fieldId": "link",
          "url": "https://aws.amazon.com/jp/blogs/aws/announcing-aws-lambda-function-urls-built-in-https-endpoints-for-single-function-microservices/"
        }
      ],
      "title": "AWS LambdaでURLを発行できるようになった",
      "body": [
        {
          "fieldId": "plainText",
          "content": "認証タイプは2通りあり、「認証されたIAMユーザーのみアクセス許可」「全ユーザーにアクセス許可」を選べるようになった。\n\nまた、オプションでCORSヘッダーも設定できる\nURLの形式はこのような感じ\n\n```shell\nhttps://xxxxx.lambda-url.ap-northeast-1.on.aws/\n```\n\n<img src=\"https://images.microcms-assets.io/assets/1eee0d842b03431580c3bb6f540e9e7b/9aeb1700cd464caa900e5c8ad91cadca/aws_lambda_url.png\" alt=\"lambda-url-setting\" width=\"732\" height=\"507\" />"
        }
      ],
      "related": []
    }
  ]
}
